# 目录

<!--自动插入TOC：https://github.com/ekalinin/github-markdown-toc-->
<!--ts-->
   * [目录](#目录)
   * [基础知识点](#基础知识点)
      * [1. 指针](#1-指针)

<!-- Added by: luyl, at: 2018-11-16T12:42+08:00 -->

<!--te-->

----

# 基础知识点

## 1. 指针

**指针与C++基本原理**

面向对象编程与传统的过程性编程的区别在于，OOP强调的是在运行阶段（而不是编译阶段）进行决策。
运行阶段指的是程序正在运行时，编译阶段指的是编译器将程序组合起来时。运行阶段决策就好比度假
时，选择参观那些景点取决于天气和当时的心情；而编译阶段决策更像不管在什么条件下，都坚持预先
设定的日程安排。

运行阶段决策提供了灵活性，可以根据当时的情况进行调整。例如，考虑为数组分配内存的情况。传统
的方法是声明一个数组。要在C+中声明数组，必须指定数组的长度。因此，数组长度在程序编译时就设
定好了；这就是编辑阶段决策。虽有可能在80%的情况下，一个包含20个元素的数组足够了，但程序有
时需要处理200个元素。为了安全起见，使用了一个包含200个元素的数组。这样，程序在大多数情况下
都浪费了内存。OOP通过将这样的决策推迟给运行阶段进行，使程序更灵活。在程序运行后，可以这次
告诉它只需要20个元素，而且还可以下次的时候告诉它需要205个元素。

总之，使用OOP时，您可以在运行阶段确定数组的长度。为了使用这种方法，语言必须允许在程序运行时
创建数组。C++采用的方法是，使用关键字new请求正确数量的内存以及使用指针来跟踪新分配的内存的
位置。

在运行阶段作决策并非OOP独有的，单使用C++编写这样的代码比使用C语言简单。

* 在C++中创建指针时，计算机将分配用来存储地址的内存，但不会分配用来存储指针所指向的数据的内存。


**数组的地址**

对数组取地址时，数组名不会被解释为其地址。等等，数组名难道不被解释为数组的地址吗？不完全如
此：数组名被解释为其第一个元素的地址，而对数组名应用地址运算符（即&）时，得到的是整个数组
的地址：

```
short tell[10];        //声明一个长度为20字节的数组（short型变量大小为2字节）
cout << tell << endl;  //显示&tell[0]
cout << &tell << endl; //显示整个数组的地址
```

从数字上说，这两个地址相同；但从概念上说，&tell[0]（即tell）是一个2字节内存块的地址，而&tell
是一个20字节内存块的地址。因此，表达式tell+1将地址值加2，而表达式&tell+1将地址值加20。换句话
说，tell是一个short指针（short*），而&tell是一个指向包含10个元素的short数组的指针
（short(*) [10]）。

您可能会问，前面有关&tell的类型描述是如何来的呢？首先，您可以这样声明和初
始化这种指针：

```
short (*pas) [10] = &tell; //pas指向一个有10个short元素的数组
```

如果省略括号，优先级规则将使pas先与[10]结合，导致pas是一个包含10个short型指针的数组，因此括
号是必不可少的。其次，如果要描述变量的类型，可将声明中的变量名删除。因此，pas的类型为
short(*) [10]。另外，由于pas被设置为tell，因此*pas与tell等价，所以(*pas) [0]为tell数组的第一
个元素。

* short  * p  [20] : 有20个元素的short指针数组
* short (* p) [20] : 指向包含20个元素的short数组的指针