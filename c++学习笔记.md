# 目录

<!--自动插入TOC：https://github.com/ekalinin/github-markdown-toc-->
<!--ts-->
   * [目录](#目录)
   * [基础知识点](#基础知识点)
      * [1. 指针](#1-指针)
      * [2. 变量](#2-变量)

<!-- Added by: luyl, at: 2018-11-16T17:15+08:00 -->

<!--te-->

----

# 基础知识点

## 1. 指针

**指针与C++基本原理**

面向对象编程与传统的过程性编程的区别在于，OOP强调的是在运行阶段（而不是编译阶段）进行决策。
运行阶段指的是程序正在运行时，编译阶段指的是编译器将程序组合起来时。运行阶段决策就好比度假
时，选择参观那些景点取决于天气和当时的心情；而编译阶段决策更像不管在什么条件下，都坚持预先
设定的日程安排。

运行阶段决策提供了灵活性，可以根据当时的情况进行调整。例如，考虑为数组分配内存的情况。传统
的方法是声明一个数组。要在C+中声明数组，必须指定数组的长度。因此，数组长度在程序编译时就设
定好了；这就是编辑阶段决策。虽有可能在80%的情况下，一个包含20个元素的数组足够了，但程序有
时需要处理200个元素。为了安全起见，使用了一个包含200个元素的数组。这样，程序在大多数情况下
都浪费了内存。OOP通过将这样的决策推迟给运行阶段进行，使程序更灵活。在程序运行后，可以这次
告诉它只需要20个元素，而且还可以下次的时候告诉它需要205个元素。

总之，使用OOP时，您可以在运行阶段确定数组的长度。为了使用这种方法，语言必须允许在程序运行时
创建数组。C++采用的方法是，使用关键字new请求正确数量的内存以及使用指针来跟踪新分配的内存的
位置。

在运行阶段作决策并非OOP独有的，单使用C++编写这样的代码比使用C语言简单。

* 在C++中创建指针时，计算机将分配用来存储地址的内存，但不会分配用来存储指针所指向的数据的内存。


**数组的地址**

对数组取地址时，数组名不会被解释为其地址。等等，数组名难道不被解释为数组的地址吗？不完全如
此：数组名被解释为其第一个元素的地址，而对数组名应用地址运算符（即&）时，得到的是整个数组
的地址：

```
short tell[10];        //声明一个长度为20字节的数组（short型变量大小为2字节）
cout << tell << endl;  //显示&tell[0]
cout << &tell << endl; //显示整个数组的地址
```

从数字上说，这两个地址相同；但从概念上说，&tell[0]（即tell）是一个2字节内存块的地址，而&tell
是一个20字节内存块的地址。因此，表达式tell+1将地址值加2，而表达式&tell+1将地址值加20。换句话
说，tell是一个short指针（short*），而&tell是一个指向包含10个元素的short数组的指针
（short(*) [10]）。

您可能会问，前面有关&tell的类型描述是如何来的呢？首先，您可以这样声明和初
始化这种指针：

```
short (*pas) [10] = &tell; //pas指向一个有10个short元素的数组
```

如果省略括号，优先级规则将使pas先与[10]结合，导致pas是一个包含10个short型指针的数组，因此括
号是必不可少的。其次，如果要描述变量的类型，可将声明中的变量名删除。因此，pas的类型为
short(*) [10]。另外，由于pas被设置为tell，因此*pas与tell等价，所以(*pas) [0]为tell数组的第一
个元素。

* short  * p  [20] : 有20个元素的short指针数组
* short (* p) [20] : 指向包含20个元素的short数组的指针


**chr*指针**

```
int a = 10;
int * p1 = &a;
cout << p1 << endl;  //打印变量a的地址

chr * b[10] = "bear";
chr * p2 = b;
cout << p2 << endl;  //打印字符串"bear"
count << (int *) p2 << endl;  //打印字符串数组的地址
```

一般来说，如果给cout提供一个指针，它将打印地址。但如果指针的类型为 chr *, 则cout将显示指向的
字符串。如果要显示的是字符串的地址，则必须将这种指针强制转换为另一种指针类型，如 int * （上面
的代码就是这样做的）。因此，p2显示为字符串"bear"，而(int *) p2 显示为该字符串的地址。



## 2. 变量

| 变量 | 存储类型 | 生命周期 | 作用域 | 连接性 |
| ---- | ---- | ---- | ---- | ---- |
| 全局变量 | 静态 |   整个程序周期内   | 所有源文件 | 外部连接性 |
| 全局变量 | 静态 |   整个程序周期内   |  本源文件  | 内部连接性 |
| 局部变量 | 静态 |   整个程序周期内   |   函数内   |     无     |
| 局部变量 | 自动 | 函数周期或代码块内 |   函数内   |     无     |


* 存储类表明变量在哪里存储，生命周期表明什么时候为变量分配、收回内存，作用域表明变量起作用的范围
（代码块，函数域，文件域）；
* 存储类决定了生命周期，作用域决定了链接属性。
* 作用域表明变量起作用的范围（代码块，函数域，文件域）；
* 链接属性有外链接、内链接、空链接（不参与链接）。

* 声明引用外部全局变量，需要extern
* 定义内部全局变量，需要static
* 定义静态局部变量，需要static
* 函数内存在同名局部变量，要使用外部全局变量需要 ::变量名

* 外部全局变量要服从单定义规则(整个程序内只能有一处定义, 其它地方用extern来引用)
