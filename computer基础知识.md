# 目录

<!--自动插入TOC：https://github.com/ekalinin/github-markdown-toc-->
<!--ts-->
   * [目录](#目录)
   * [基础知识](#基础知识)
      * [浮点数](#浮点数)

<!-- Added by: luyl, at: 2018-11-01T10:56+08:00 -->

<!--te-->

----

# 基础知识

## 浮点数

* [浮点数在内存中的存储方式](https://blog.csdn.net/d_leo/article/details/53046721)
* [浮点数比较大小的问题](https://blog.csdn.net/liujian20150808/article/details/50630546)
* [浮点数的大小比较为什么不能用等号](https://www.cnblogs.com/xiehongfeng100/p/4851201.html)

**浮点数在内存中的存储方式**

浮点数类型包括float、double、long double
在这里以float为例。
先看一段代码：
```
#include<stdio.h>
#include<windows.h>
int main()
{
	int a = 9;
	float *pa = (float *)&a;
	printf("a = %d\n", a);
	printf("*pa = %f\n", *pa);
	*pa = 9.0;
	printf("a = %d\n", a);
	printf("*pa = %f\n", *pa);
	system("pause");
	return 0;
}</span>

# 结果
a = 9
*pa = 0.000000
a = 1091567616
*pa = 9.000000
```
为什么会有这样的结果呢？简单分析一下：

对于9和9.0在内存中肯定都以补码的形式存在，因为int和float对于这串补码的处理方式不同所以才会得到不一样的结果。

而对于float到底是怎样在内存中存储的呢？这就是我们讨论的重点!

根据国际标准IEEE（电气和电子工程协会）规定，任何一个浮点数NUM的二进制数可以写为：

NUM = (-1)^S\*M\*2^E;//(S表示符号，E表示阶乘，M表示有效数字)

* 当S为0时，表示一个正数；当S为1时，表示一个负数
* M表示有效数字，1<= M <2
* 2^E表示指数

比如十进制的3.0，二进制就是0011.0 就可以写成（-1）^0\*1.1\*2^1 

在比如十进制的-3.0，二进制就是-0011.0 就可以写成（-1）^1\*1.1\*2^1 

而规定float类型有一个符号位（S），有8个指数位（E），和23个有效数字位（M）

     double类型有一个符号位（S），有11个指数位（E），和52个有效数字位（M）

以float类型为例：

![](https://img-blog.csdn.net/20161105184604775?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center)

IEEE对于（有效数字）M和（指数）E有特殊的规定： （以float为例）

1. 因为M的值一定是1<= M <2，所以它绝对可以写成1.xxxxxxx的形式，所以规定M在存储时舍去第一个1，只存储小数点之
后的数字。这样做节省了空间，以float类型为例，就可以保存23位小数信息，加上舍去的1就可以用23位来表示24个有效
的信息。
2. 对于E（指数）E是一个无符号整数所以E的取值范围为（0\~255），但是在计数中指数是可以为负的，所以规定在存入E时，
在它原本的值上加上中间数（127），在使用时减去中间数（127），这样E的真正取值范围就成了（-127\~128）。
对于E还分为三种情况：
	* E不全为0，不全为1: 这时就用正常的计算规则，E的真实值就是E的字面值减去127（中间值)，M的值要加上最前面的
	省去的1。
	* E全为0: 这时指数E等于1-127为真实值，M不在加上舍去的1，而是还原为0.xxxxxxxx小数。这样为了表示0，和一些很
	小的整数。所以在进行浮点数与0的比较时，要注意。
	* E全为1: 当M全为0时，表示±无穷大（取决于符号位）；当M不全为1时，表示这数不是一个数（NaN）

在看刚开始的题目：

`int a = 9`;因为a是int类型的，所以他在内存中以补码的形式储存：

00000000 00000000 00000000 00001001

而*pa却是float类型的所以，当*pa读这块内存的值时，它通过浮点数的形式读取

S: 0

E: 0000000 0

M: 0000000 00000000 00001001        

`*pa = （-1）^0 * (0.0000000 00000000 00001001) * 2^(1-127)`  这个数是一个很小的数，用十进制小数表示就是
 0.000000

`*pa = 9.0`;因为\*pa是float类型的，所以9可以写为`（1001）= (-1)^0 * (1.001) * 2^(3)` 所以：

S = 0   M = 001000……    E = 3 + 127 = 130

S: 0

E: 1000001 0

M: 0010000 00000000 00000000    

而把这个二进制数还原为十进制数就为1091567616就是a的值


**浮点数比较大小**

浮点数比较大小，由于精度问题，所以直接比较有时可能会出错。

单精度数7位有效数字。 （float）

双精度数16位有效数字。（double）

单精度数的尾数用23位存储，加上默认的小数点前的1位1，2^(23+1) = 16777216。因为 10^7 < 16777216 < 10^8，
所以说单精度浮点数的有效位数是7位。 双精度的尾数用52位存储，2^(52+1) = 9007199254740992，
10^16 < 9007199254740992 < 10^17，所以双精度的有效位数是16位


所以在比较的时候需要用一个很小的数值来进行比较。（二分法的思想）当二者之差小于这个很小的数时，
就认为二者是相等的了。这个很小的数，称为精度。

精度由计算过程中需求而定。比如一个常用的精度为1e-6.也就是0.000001.

所以对于两个浮点数a,b，如果要比较大小，那么常常会设置一个精度

如果fabs(a-b)<=1e-6，那么就是相等了。 fabs是求浮点数绝对值的函数。

类似的 判断大于的时候，就是`if(a>b && fabs(a-b)>1e-6)`。

判断小于的时候，就是`if(a<b&&fabs(a-b)>1e-6)`。

```
#include<cstdio>
#include<cmath>
const double esp = 1e-6;
int main()
{
    double a,b;
    scanf("%lf %lf",&a,&b);
    if(fabs(a - b) <= esp)
        printf("ok\n");
    else
        printf("no\n");
    return 0;
}
```


**浮点数的大小比较为什么不能用等号？**

下文将从几个方面来探索这个问题：

* 浮点数精度不同
* 寄存器与内存表示浮点数精度不同: 即使在精度相同的情况下，比较也可能会出问题。因为在运算过程中会将内存
（或高速缓存）中的值加载到CPU浮点寄存器（80 bit扩展精度）中，然后再进入CPU浮点计算单元进行计算，计算结果
写回浮点寄存器，然后写回内存（或高速缓存）。从内存到浮点寄存器，浮点数的精度会扩展，从浮点寄存器到内存，
浮点数的精度会降低(精度扩展通常没问题，但如果精度降低了，很可能值会发生变化，出现截断)，而浮点运算的结果
由于下面还要使用所以暂时保存在浮点寄存器中留待下次使用（没有及时写回内存，这是一种优化策略），从而导致数据
并不是内存中和内存中的数据比较而是浮点寄存器中的值和内存中的值进行比较，而无论内存中是float类型还是double
类型，其精度和浮点寄存器精度都不相同，从而导致比较结果是不相等。  